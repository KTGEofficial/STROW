<!DOCTYPE html>
<html lang="en">
<style id="dynamic-theme"></style>
  <script>
    const lightCSS = `
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow-x: hidden;
        overflow-y: auto;
        background: linear-gradient(to bottom left, hsl(180, 96%, 96%), hsl(150, 96%, 96%));
        font-family: sans-serif;
      }

      .grid-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(to right, rgba(255, 255, 255, 0.5) 8px, transparent 1px),
          linear-gradient(to bottom, rgba(255, 255, 255, 0.5) 8px, transparent 1px);
        background-size: 40px 40px;
        pointer-events: none;
        z-index: 0;
      }

      .content {
        position: relative;
        z-index: 1;
        padding: 2rem;
        text-align: center;
      }
    `;

    const darkCSS = `
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow-x: hidden;
        overflow-y: auto;
        background: linear-gradient(to bottom left, hsl(240, 96%, 16%), hsl(0, 0%, 0%), hsl(332, 96%, 32%));
        font-family: sans-serif;
        color: white;
      }

      .grid-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(to right, rgba(255, 255, 255, 0.125) 8px, transparent 1px),
          linear-gradient(to bottom, rgba(255, 255, 255, 0.125) 8px, transparent 1px);
        background-size: 40px 40px;
        pointer-events: none;
        z-index: 0;
      }

      .content {
        position: relative;
        z-index: 1;
        padding: 2rem;
        text-align: center;
      }
    `;

    function applyTheme() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const styleTag = document.getElementById('dynamic-theme');
      styleTag.textContent = prefersDark ? darkCSS : lightCSS;
    }

    applyTheme();

    // Optional: Listen for changes in system theme
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
  </script><head>
  <meta charset="UTF-8">
  <title>STROW Search</title>
  <style>
    input[type="search"] {
      background-color: white;
      border: 3px solid transparent;
      border-radius: 1rem;
      padding: 0.6rem 1rem;
      font-size: 1rem;
      width: 100%;
      text-align: center;
      box-sizing: border-box;
      outline: none;
      background-image:
        linear-gradient(to bottom left, #00FFFF, #00FF7F),
        white;
      background-origin: border-box;
      background-clip: padding-box, border-box;
      box-shadow: 0 0 8px rgba(0,255,127,0.4);
      transition: box-shadow 0.3s ease;
    }

    input[type="search"]:focus {
      box-shadow: 0 0 8px rgba(0,255,255,0.5);
    }

    .button-link {
      position: relative;
      display: inline-block;
      text-decoration: none;
      color: white;
      font-size: 1rem;
      font-weight: bold;
      padding: 0.75rem 1.5rem;
      margin-top: 1rem;
      border-radius: 1rem;
      background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F);
      box-shadow: 0 4px 8px rgba(0,255,127,0.3);
      cursor: pointer;
      overflow: hidden;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      z-index: 1;
    }

    .button-link:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 12px rgba(0,255,255,0.4);
    }

    .button-link:active {
      transform: scale(0.98);
      box-shadow: 0 2px 6px rgba(0,255,255,0.2);
    }

    .ripple-outline {
      position: absolute;
      border: 2px solid rgba(0,255,255,0.4);
      border-radius: 1rem;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      transform: scale(1);
      animation: ripple-outline-animation 800ms ease-out;
      pointer-events: none;
      z-index: 0;
    }

    @keyframes ripple-outline-animation {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      100% {
        transform: scale(2.5);
        opacity: 0;
      }
    }
.search-results {
  background: #f9fbff;
  border: 1px solid #d0e0f0;
  border-radius: 8px;
  padding: 1em;
  margin-top: 2em;
  box-shadow: 0 2px 6px rgba(0,0,0,0.05);
}

.result-card {
  background: none;
  padding: 1em;
  margin-bottom: 1em;
  border-radius: 6px;
  transition: transform 0.2s ease;
}

.result-card:hover {
  transform: scale(1.02);
  background: #eef6ff;
}

.result-title {
  font-size: 1.2em;
  font-weight: bold;
  margin-bottom: 0.3em;
}

.result-meta {
  font-size: 0.9em;
  color: #555;
  margin-bottom: 0.5em;
}

  </style>
</head>
<body>
  <div class="grid-overlay"></div>
  <div id="strow-container"></div>
<div class="search-results" id="search-results">
</div>

  <script>
    async function getRawFingerprintData() {
      const traits = [
        navigator.userAgent,
        navigator.language,
        screen.width,
        screen.height,
        screen.colorDepth,
        new Date().getTimezoneOffset(),
        navigator.platform,
        navigator.hardwareConcurrency,
        navigator.deviceMemory || 'unknown'
      ];
      return traits.join('::');
    }

    async function generateHexFingerprint(rawData) {
      const encoder = new TextEncoder();
      const buffer = await crypto.subtle.digest('SHA-256', encoder.encode(rawData));
      return Array.from(new Uint8Array(buffer))
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');
    }
function findColorScheme(){const e=!window.matchMedia("(prefers-color-scheme: dark)").matches;return document.getElementById("dynamic-theme").textContent=e?lightCSS:darkCSS,e}
    async function validateFingerprint() {
      const rawData = await getRawFingerprintData();
      const hexFingerprint = await generateHexFingerprint(rawData);

      const macroURL = "https://script.google.com/macros/s/AKfycbzt8rTZGVPRA4yLsMN8RgGGotQ8rxcrtADoO2gsBa2KMQEW9uqRPVuYeI1MaQlS2hzA/exec";
      const query = new URLSearchParams({ mode: "cssc", fingerprint: hexFingerprint, colorscheme: findColorScheme() }).toString();
      const response = await fetch(`${macroURL}?${query}`);
      const result = await response.json();

      if (result.row !== null && result.username) {
        mountSearchUI(result.username);
      } else {
        window.location.href =
          'https://ktgeofficial.github.io/STROW/accountchange.html';
      }
    }
function wordMatchMultiplier(t,e){const l=t.split(/\s+/).filter((t=>/\w/.test(t))).map((t=>t.toLowerCase())),r=e.split(/\s+/).filter((t=>/\w/.test(t))).map((t=>t.toLowerCase()));let o=0;return l.forEach((l=>{let h=0;r.forEach((r=>{const o=Array.from({length:t.length+1},(()=>Array(e.length+1).fill(0)));for(let t=0;t<=l.length;t++)o[t][0]=t;for(let t=0;t<=r.length;t++)o[0][t]=t;for(let t=1;t<=l.length;t++)for(let e=1;e<=r.length;e++){const h=l[t-1]===r[e-1]?0:1;o[t][e]=Math.min(o[t-1][e]+1,o[t][e-1]+1,o[t-1][e-1]+h)}const n=o[l.length][r.length],a=Math.floor(l.length/2),f=Math.max(0,1-n/(a||1));n<=a&&(h=Math.max(h,f))})),o+=h})),Math.max(o,.01)}
    function calculateTimeMultiplier(nowUTC, releaseInput, deadlineInput) {
      if (!deadlineInput) {
        return 1;
      }
      const releaseTime = new Date(releaseInput).getTime();
      const deadlineTime = new Date(deadlineInput).getTime();
      const nowTime = new Date(nowUTC).getTime();
      if (deadlineTime <= releaseTime) {
        return 1;
      }
      const totalDuration = deadlineTime - releaseTime;
      const elapsed = nowUTC - releaseTime;
      const progressRatio = elapsed / totalDuration;
      if (progressRatio <= 1) {
    return (6 * Math.pow(progressRatio, 3)) - (5 * Math.pow(progressRatio, 2)) + 1.5;
  } else {
    return 0.6 * Math.pow(2.5, (2 - progressRatio)) + 1;
  }
}

function calculateFinalScores(nowUTC, jsonData, searchQuery) {
  const scores = {};

  for (const id in jsonData) {
    const entry = jsonData[id];
    const views = entry.views || 0;
    const release = entry.timestamp;
    const deadline = entry.deadline;

    const timeMultiplier = calculateTimeMultiplier(nowUTC, release, deadline);
    const referenceText = `${entry.title} ${entry.uploader} ${entry.description}`;
    const wordMultiplier = wordMatchMultiplier(searchQuery, referenceText);

    const finalScore = (views + 1) * timeMultiplier * wordMultiplier;

    scores[id] = {
      title: entry.title.trim(),
      uploader: entry.uploader,
      finalScore: parseFloat(finalScore)
    };
  }

  return scores;
}
function renderSortedResults(scores) {
  const container = document.getElementById("search-results");
  container.innerHTML = "";
  const sortedEntries = Object.entries(scores).sort(([, a], [, b]) => b.finalScore - a.finalScore);
  sortedEntries.forEach(([videoID, entry]) => {
    const anchor = document.createElement("a");
    anchor.href = `https://ktgeofficial.github.io/STROW/video.html?id=${videoID}`;
    anchor.style.textDecoration = "none";
    anchor.style.color = "inherit";
    const card = document.createElement("div");
    card.className = "result-card";
    const titleDiv = document.createElement("div");
    titleDiv.className = "result-title";
    titleDiv.textContent = entry.title;
    const uploaderDiv = document.createElement("div");
    uploaderDiv.className = "result-meta";
    uploaderDiv.textContent = `Uploaded by ${entry.uploader}`;
    const idDiv = document.createElement("div");
    idDiv.className = "result-meta";
    idDiv.textContent = videoID;
    card.appendChild(titleDiv);
    card.appendChild(uploaderDiv);
    card.appendChild(idDiv);
    anchor.appendChild(card);
    container.appendChild(anchor);
  });
}
const urlParams = new URLSearchParams(window.location.search);
if (!urlParams.has("id")) {
  (async () => {
    try {
      const query = new URLSearchParams({
        mode: "search",
        fingerprint: await generateHexFingerprint(getRawFingerprintData()),
        colorscheme: findColorScheme(),
        ishomepage: false,
        searchquery: ""
      }).toString();

      const response = await fetch(
        "https://script.google.com/macros/s/AKfycbws83E6-z_290aPyNfg-fzm2dgoyngCmQrezcitwW0CAwIJSmsUUikA4Y7Jq1yGRrSn/exec?" + query
      );
      const result = await response.json();
      console.log(result);
      // Ritualize result into UI, glyphs, or emotional metadata
    } catch (error) {
      console.error("Failed to fetch video data:", error);
    }
  })();
}
else {
  (async () => {
    try {
      const nowUTC = new Date().getTime()
      const query = new URLSearchParams({
        mode: "search",
        fingerprint: await generateHexFingerprint(getRawFingerprintData()),
        colorscheme: findColorScheme(),
        ishomepage: false,
        searchquery: new URLSearchParams(window.location.search).get("id"),
        timestamp: nowUTC
      }).toString();

      const response = await fetch(
        "https://script.google.com/macros/s/AKfycbws83E6-z_290aPyNfg-fzm2dgoyngCmQrezcitwW0CAwIJSmsUUikA4Y7Jq1yGRrSn/exec?" + query
      );
      const result = await response.json();
      console.log(result);
      const scores = calculateFinalScores(nowUTC, result, new URLSearchParams(window.location.search).get("id"));
renderSortedResults(scores);
    } catch (error) {
      console.error("Failed to fetch video data:", error);
    }
  })();
}
    function mountSearchUI(username) {
      const container = document.getElementById('strow-container');
      container.innerHTML = `
        <div class="content">
          <h1>STROW Search</h1>
          <p>You are logged in as ${username}</p>
          <input
            type="search"
            id="searchInput"
            placeholder="Please enter something that you want to search"
          /><br/>
          <a href="#"
             id="searchButton"
             class="button-link">
            Search
          </a>
        </div>
      `;

      const inputEl = document.getElementById('searchInput');
      const btnEl   = document.getElementById('searchButton');

      btnEl.addEventListener('click', e => {
        e.preventDefault();
        const query = inputEl.value.trim();
        if (!query) return; // no empty searches
        // ripple effect
        const ripple = document.createElement('div');
        ripple.className = 'ripple-outline';
        btnEl.appendChild(ripple);
        setTimeout(() => btnEl.removeChild(ripple), 800);

        // navigate after small delay so ripple shows
        setTimeout(() => {
          window.location.href = 
            `https://ktgeofficial.github.io/STROW/search.html?id=${encodeURIComponent(query)}`;
        }, 100);
      });
    }

    validateFingerprint();
  </script>
</body>
</html>
