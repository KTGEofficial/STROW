<html>
<head>
    <style id="dynamic-theme"></style>
  <script>
    const lightCSS = `body,html{margin:0;padding:0;height:100%;overflow-x:hidden;overflow-y:auto;background:linear-gradient(to bottom left,#ebffff,#ebfff5);font-family:sans-serif}.grid-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-image:linear-gradient(90deg,hsla(0,0%,100%,.5) 8px,transparent 0),linear-gradient(180deg,hsla(0,0%,100%,.5) 8px,transparent 0);background-size:40px 40px;pointer-events:none;z-index:0}.content{position:relative;z-index:1;padding:2rem;text-align:center}`;

    const darkCSS = `body,html{margin:0;padding:0;height:100%;overflow-x:hidden;overflow-y:auto;background:linear-gradient(to bottom left,#020250,#000,#a0034c);font-family:sans-serif;color:#fff}.grid-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background-image:linear-gradient(90deg,hsla(0,0%,100%,.125) 8px,transparent 0),linear-gradient(180deg,hsla(0,0%,100%,.125) 8px,transparent 0);background-size:40px 40px;pointer-events:none;z-index:0}.content{position:relative;z-index:1;padding:2rem;text-align:center}`;

    function applyTheme() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const styleTag = document.getElementById('dynamic-theme');
      styleTag.textContent = prefersDark ? darkCSS : lightCSS;
    }

    applyTheme();

    // Optional: Listen for changes in system theme
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
  </script><title>Watching STROW</title><style>
        
        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            transition: all 0.3s ease;
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            /* Green glow when not focused */
            box-shadow: 0 0 8px rgba(0, 255, 127, 0.4);
            transition: box-shadow 0.3s ease;
        }

            /* Optional: subtle cyan glow on focus */
            input[type="text"]:focus,
            input[type="url"]:focus {
                box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
            }
.button-link,
.button-link:focus,
.button-link:active {
  outline: none;
  border: none;
}

        .button-link {
            position: relative;
            display: inline-block;
            text-decoration: none;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 1rem;
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F); /* Gradient restored */
            box-shadow: 0 4px 8px rgba(0, 255, 127, 0.3);
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 1;
        }


            .button-link:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 12px rgba(0, 255, 255, 0.4);
            }

            .button-link:active {
                transform: scale(0.98);
                box-shadow: 0 2px 6px rgba(0, 255, 255, 0.2);
            }

        .ripple-outline {
            position: absolute;
            border: 2px solid rgba(0, 255, 255, 0.4); /* Soft green glow */
            border-radius: 1rem;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            transform: scale(1);
            animation: ripple-outline-animation 800ms ease-out;
            pointer-events: none;
            z-index: 0; /* Behind the button text 2:06:58:53 */

        }


        @keyframes ripple-outline-animation {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }.comment-section {
  background: none;
  padding: 1.5em;
  margin-top: 2em;
  max-width: 700px;
  margin-left: auto;
  margin-right: auto;
}

.comment {
  padding: 1em;
  margin-bottom: 1em;
  border-radius: 6px;
}
    </style>
</head>
<body>
    <div class="grid-overlay"></div>

<div style="position: relative; height: 100vh; background-color: hsl(0deg 0% 100% / 0%); padding: 2rem;">
  <iframe
    id="videoPreview"
    src=""
    frameborder="0"
    allowfullscreen
    style="width: 840px; height: 472.5px;">
  </iframe>
  <h1 id="videoTitle">Loading Title</h1>
  <h2 id="countdown">Waiting for deadline</h2>
  <p id="videoDescription">Loading description</p>
  <h4 id="videoAuthor">From undefined at undefined</h4>
  <p id="videoDeadline">Deadline: Loading</p>
  <a id="spreadsheetLink" class="button-link">Spreadsheet</a>
  <a id="externalLink" class="button-link">Alternate External</a>
  <h2 id="commentCount">0 Comments</h2>
<input type="text" id="comment"><br><br><button class="button-link" id="comment-button" onclick="submitComment()">Comment</button><br><div class="comment-section" id="comment-section">
</div>
</div>
<script>
function findColorScheme(){const e=!window.matchMedia("(prefers-color-scheme: dark)").matches;return document.getElementById("dynamic-theme").textContent=e?lightCSS:darkCSS,e}// Function to get raw fingerprint data from various browser traits
async function getRawFingerprintData() {
  const traits = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    screen.colorDepth,
    new Date().getTimezoneOffset(),
    navigator.platform,
    navigator.hardwareConcurrency,
    navigator.deviceMemory || 'unknown',
  ];
  return traits.join('::');
}

// Function to generate a SHA-256 hash from the raw fingerprint data
async function generateHexFingerprint(rawData) {
  const encoder = new TextEncoder();
  const buffer = await crypto.subtle.digest('SHA-256', encoder.encode(rawData));
  return Array.from(new Uint8Array(buffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// Function to update the countdown display (PATCHED)
function updateCountdown(deadlineRaw, hasDeadline) {
  const countdownElement = document.getElementById("countdown");

  if (!hasDeadline || !deadlineRaw) {
    countdownElement.textContent = "No deadline";
    return;
  }

  // Convert deadlineRaw to a timestamp if it's a string
  let deadlineTime = typeof deadlineRaw === "number" ? deadlineRaw : Date.parse(deadlineRaw);
  if (isNaN(deadlineTime)) {
    countdownElement.textContent = "Invalid deadline date";
    return;
  }

  const now = Date.now();
  const distance = deadlineTime - now;

  if (distance <= 0) {
    countdownElement.textContent = "The deadline has passed";
    return;
  }

  const days = Math.floor(distance / (1000 * 60 * 60 * 24));
  const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
  const minutes = Math.floor((distance / (1000 * 60)) % 60);
  const seconds = Math.floor((distance / 1000) % 60);

  let partsToDisplay = [];

  if (days >= 1) {
    partsToDisplay.push(`${days}:${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (hours >= 1) {
    partsToDisplay.push(`${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (minutes >= 1) {
    partsToDisplay.push(`${minutes}:${String(seconds).padStart(2, '0')}`);
  } else {
    partsToDisplay.push(`${seconds} seconds`);
  }

  countdownElement.textContent = partsToDisplay.join("");
}

// Function to format the date and time for display
function formatDeadline(dateString, includeTime = false, timezoneAbbreviation) {
  const date = new Date(dateString);

  if (isNaN(date.getTime())) {
    return "Invalid Date";
  }

  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  let formatted = date.toLocaleDateString(undefined, options);

  // Add ordinal suffix (1st, 2nd, 3rd, 4th...)
  const day = date.getDate();
  const suffix = (day % 10 === 1 && day !== 11) ? 'st' :
                 (day % 10 === 2 && day !== 12) ? 'nd' :
                 (day % 10 === 3 && day !== 13) ? 'rd' : 'th';
  formatted = formatted.replace(/\d+/, day + suffix);

  if (includeTime) {
    const timeOptions = {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    };
    // NO timeZone property; uses the browser's local zone
    const localTime = `${date.toLocaleTimeString(undefined, timeOptions)} ${timezoneAbbreviation}`;
    formatted += ` at ${localTime}`;
  }

  return formatted;
}

// Main function to load video data and update the page
async function loadVideoData() {
  const params = new URLSearchParams(window.location.search);
  const id = params.get("id");

  if (!id) {
    window.location.href = "https://ktgeofficial.github.io/STROW/";
    return;
  }

  const rawData = await getRawFingerprintData();
  const fingerprint = await generateHexFingerprint(rawData);

  const query = new URLSearchParams({
    mode: "watch",
    id,
    fingerprint,
    timezoneOffset: new Date().getTimezoneOffset(),
    timezoneAbbreviation: Intl.DateTimeFormat('en-US', {timeZoneName: 'short'}).formatToParts(new Date()).find(part => part.type === 'timeZoneName')?.value,
    colorscheme: findColorScheme()
  }).toString();

  try {
    const response = await fetch(`https://script.google.com/macros/s/AKfycbxtI0fzk-wnS-xjS8OD9Pvg1wI2EvqeHLUnvUmVbMAaDPBSITcIOMq1fvAmlqQ1wuuW/exec?${query}`);
    const result = await response.json();
console.log(result);
    if (!result.success) {
      console.log(result);
      window.location.href = result.redirect || "https://ktgeofficial.github.io/STROW/";
      return;
    }

    async function makeLink(url, fetchTitle = false) {
      let text = url;

      if (fetchTitle && /^https?:\/\//i.test(url)) {
        try {
          const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
          const data = await response.json();
          const match = data.contents.match(/<title>(.*?)<\/title>/i);
          if (match && match[1]) text = match[1].trim();
        } catch (e) {
          console.warn("Could not fetch title for:", url, e);
        }
      }

      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = text;
      return a;
    }

    // Convert deadlineRaw to timestamp once for countdown logic
    const deadlineTimestamp = typeof result.deadlineRaw === "number"
      ? result.deadlineRaw
      : Date.parse(result.deadlineRaw);

    document.getElementById("videoTitle").textContent = result?.title?.trim();

    const descriptionContainer = document.getElementById("videoDescription");
    descriptionContainer.innerHTML = "";

    const descriptionLines = (result?.description || "").split("\n");
    descriptionLines.forEach(line => {
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const p = document.createElement("p");
        p.textContent = trimmedLine;
        descriptionContainer.appendChild(p);
      }
    });

    document.getElementById("videoAuthor").textContent =
      `From ${result.author} at ${formatDeadline(result.uploadDate, false, result.timezoneAbbreviation) || result.uploadDate}`;
    document.getElementById("videoDeadline").textContent =
      `Deadline: ${formatDeadline(result.deadlineRaw, true, result.timezoneAbbreviation) || result.deadlineRaw}`;
    document.getElementById("spreadsheetLink").href = result.spreadsheetHref || "#";
    document.getElementById("externalLink").href = result.externalHref || "#";
if (result.commentCount === 1) { document.getElementById("commentCount").textContent = "1 Comment"; } else {
    document.getElementById("commentCount").textContent = `${result.commentCount || 0} Comments`; }
  const container = document.getElementById("comment-section");
  container.innerHTML = ""; // Clear previous comments

  const commentIDs = Object.keys(result.comments);

  for (let i = commentIDs.length - 1; i >= 0; i--) {
    const id = commentIDs[i];
    const commentData = result[id];

    if (!commentData || typeof commentData !== "object") continue;

    const commentDiv = document.createElement("div");
    commentDiv.className = "comment";

    const authorP = document.createElement("p");
    const boldAuthor = document.createElement("b");
    boldAuthor.textContent = commentData.username;
    authorP.appendChild(boldAuthor);

    const textP = document.createElement("p");
    textP.textContent = commentData.comment || "";

    commentDiv.appendChild(authorP);
    commentDiv.appendChild(textP);
    container.appendChild(commentDiv);
  }

    // PATCHED DYNAMIC COUNTDOWN LOGIC
    updateCountdown(deadlineTimestamp, !!deadlineTimestamp);
    setInterval(() => updateCountdown(deadlineTimestamp, !!deadlineTimestamp), 1000);

    if (result.videoLink) {
      document.getElementById("videoPreview").src = result.videoLink;
      document.getElementById("videoPreview").style.width = `${result.width}px`;
      document.getElementById("videoPreview").style.height = `${result.height}px`;
    }

  } catch (err) {
    console.error(err);
    document.getElementById("videoTitle").textContent = "Error loading video.";
  }
}
// This is a quality marker for if the HTML Page loaded is the correct one for debuggers

// Ok! Good to know, thanks!
(async () => {
  const rawData = await getRawFingerprintData();
  const hexFingerprint = await generateHexFingerprint(rawData);
  const query = new URLSearchParams({
    mode: "cssc",
    fingerprint: hexFingerprint,
    colorscheme: findColorScheme()
  }).toString();

  const response = await fetch(`https://script.google.com/macros/s/AKfycbxtI0fzk-wnS-xjS8OD9Pvg1wI2EvqeHLUnvUmVbMAaDPBSITcIOMq1fvAmlqQ1wuuW/exec?${query}`);
  const result = await response.json();
  console.log("CSSC result:", result);
})();

async function submitComment() {
  const button = document.getElementById("comment-button");
  button.disabled = true;

  try {
    const commentText = document.getElementById("comment").value.trim();
    if (!commentText) {
      alert("Please enter a comment before submitting.");
      button.disabled = false;
      return;
    }

    const rawData = await getRawFingerprintData();
    const hexFingerprint = await generateHexFingerprint(rawData);
    const timestamp = new Date().toISOString();
    const urlParams = new URLSearchParams(window.location.search);
    const videoID = urlParams.get("id") || "";
    const colorscheme = findColorScheme();
    const replyof = "";
const mode = "commenting";

    const query = new URLSearchParams({
      comment: commentText,
      timestamp: timestamp,
      fingerprint: hexFingerprint,
      id: videoID,
      colorscheme: colorscheme,
      replyof: replyof,
mode: mode
    }).toString();

    const response = await fetch("https://script.google.com/macros/s/AKfycbxtI0fzk-wnS-xjS8OD9Pvg1wI2EvqeHLUnvUmVbMAaDPBSITcIOMq1fvAmlqQ1wuuW/exec?" + query);
    const result = await response.json();

    alert("Your comment has been submitted.");
    // Optionally clear the input or show feedback
    document.getElementById("comment").value = "";
  } catch (error) {
    console.error("Failed to submit comment:", error);
    alert("Something went wrong while submitting your comment.");
  } finally {
    button.disabled = false;
  }
}

loadVideoData();
</script>

</body>
</html>





