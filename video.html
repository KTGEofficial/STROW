<html>
<head>
    <title>Watching STROW</title><style>
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrolling on <html> */
            background: linear-gradient(to bottom left, hsl(180, 96%, 96%), hsl(150, 96%, 96%));
            font-family: sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-y: auto; /* ? Enable vertical scroll on body only */
            overflow-x: hidden; /* Prevent horizontal scroll */
            position: relative;
            z-index: 1; /* Ensure body content is above the grid */
        }

        .grid-overlay {
            position: fixed; /* Stays in place while scrolling */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(to right, rgba(255, 255, 255, 0.5) 8px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.5) 8px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none; /* ? Allows interaction with content and scrollbar */
            z-index: 0; /* Behind all content */
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            transition: all 0.3s ease;
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            /* Green glow when not focused */
            box-shadow: 0 0 8px rgba(0, 255, 127, 0.4);
            transition: box-shadow 0.3s ease;
        }

            /* Optional: subtle cyan glow on focus */
            input[type="text"]:focus,
            input[type="url"]:focus {
                box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
            }
.button-link,
.button-link:focus,
.button-link:active {
  outline: none;
  border: none;
}

        .button-link {
            position: relative;
            display: inline-block;
            text-decoration: none;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 1rem;
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F); /* Gradient restored */
            box-shadow: 0 4px 8px rgba(0, 255, 127, 0.3);
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 1;
        }


            .button-link:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 12px rgba(0, 255, 255, 0.4);
            }

            .button-link:active {
                transform: scale(0.98);
                box-shadow: 0 2px 6px rgba(0, 255, 255, 0.2);
            }

        .ripple-outline {
            position: absolute;
            border: 2px solid rgba(0, 255, 255, 0.4); /* Soft green glow */
            border-radius: 1rem;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            transform: scale(1);
            animation: ripple-outline-animation 800ms ease-out;
            pointer-events: none;
            z-index: 0; /* Behind the button text 2:06:58:53 */

        }


        @keyframes ripple-outline-animation {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="grid-overlay"></div>

<div style="position: relative; height: 100vh; background-color: hsl(0deg 0% 100% / 0%); padding: 2rem;"><form>
  <iframe
    id="videoPreview"
    src=""
    frameborder="0"
    allowfullscreen
    style="width: 840px; height: 472.5px;">
  </iframe>

  <h1 id="videoTitle">Loading Title</h1>

  <h2 id="countdown">Waiting for deadline</h2>

  <p id="videoDescription">Loading description</p>

  <h4 id="videoAuthor">From undefined at undefined</h4>

  <p id="videoDeadline">Deadline: Loading</p>

  <a id="spreadsheetLink" class="button-link">Spreadsheet</a>
  <a id="externalLink" class="button-link">Alternate External</a>

  <h2 id="commentCount">0 Comments</h2>
</form></div>
<script>
  async function getRawFingerprintData() {
    const traits = [
      navigator.userAgent,
      navigator.language,
      screen.width,
      screen.height,
      screen.colorDepth,
      new Date().getTimezoneOffset(),
      navigator.platform,
      navigator.hardwareConcurrency,
      navigator.deviceMemory || 'unknown',
    ];
    return traits.join('::');
  }

  async function generateHexFingerprint(rawData) {
    const encoder = new TextEncoder();
    const buffer = await crypto.subtle.digest('SHA-256', encoder.encode(rawData));
    return Array.from(new Uint8Array(buffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }

function updateCountdown(deadlineUTC, hasDeadline) {
  const countdownElement = document.getElementById("countdown");

  if (!hasDeadline) {
    countdownElement.textContent = "No deadline";
    return;
  }

  const deadline = new Date(deadlineUTC).getTime(); // Convert to local automatically
  const now = Date.now();
  const distance = deadline - now;

  if (distance <= 0) {
    countdownElement.textContent = "The deadline has passed";
    return;
  }

  const days = Math.floor(distance / (1000 * 60 * 60 * 24));
  const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
  const minutes = Math.floor((distance / (1000 * 60)) % 60);
  const seconds = Math.floor((distance / 1000) % 60);

  let parts = [];

  if (days >= 1) {
    parts.push(`${days}:${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (hours >= 1) {
    const hoursStr = hours >= 10 ? hours : hours.toString(); // remove leading zero if <10
    parts.push(`${hoursStr}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (minutes >= 1) {
    const minutesStr = minutes >= 10 ? minutes : minutes.toString(); // remove leading zero if <10
    parts.push(`${minutesStr}:${String(seconds).padStart(2, '0')}`);
  } else {
    parts.push(`${seconds} seconds`);
  }

  countdownElement.textContent = parts.join("");
}

function formatDeadline(dateString, includeTime = false) {
  const date = new Date(dateString); // Local time
  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  let formatted = date.toLocaleDateString(undefined, options);

  // Add ordinal suffix (1st, 2nd, 3rd, 4th...)
  const day = date.getDate();
  const suffix = (day % 10 === 1 && day !== 11) ? 'st' :
                 (day % 10 === 2 && day !== 12) ? 'nd' :
                 (day % 10 === 3 && day !== 13) ? 'rd' : 'th';
  formatted = formatted.replace(/\d+/, day + suffix);

  if (includeTime) {
    const timeOptions = {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
      timeZoneName: 'short' // 'short' will give abbreviations like 'EST', 'PST'
    };
    const localTime = date.toLocaleTimeString(undefined, timeOptions);
    formatted += ` at ${localTime}`;
  }

  return formatted;
}

  async function loadVideoData() {
    const params = new URLSearchParams(window.location.search);
    const id = params.get("id");

    if (!id) {
      window.location.href = "https://ktgeofficial.github.io/STROW/";
      return;
    }

    const rawData = await getRawFingerprintData();
    const fingerprint = await generateHexFingerprint(rawData);

    const query = new URLSearchParams({ 
      mode: "watch", 
      id, 
      fingerprint 
    }).toString();

    try {
      const response = await fetch(`https://script.google.com/macros/s/AKfycbwmdFNZ4Vz_mYGub2uGSTHhGE6rtM5C_fys983BT69nPeaR0bsM7mb-CNuhsRjgC6wR/exec?${query}`);
      const result = await response.json();

      if (!result.success) {
        console.log(result);
        // Optional: redirect on fail
        // window.location.href = result.redirect || "https://ktgeofficial.github.io/STROW/";
        return;
      }

      document.getElementById("videoTitle").textContent = result.title || "Untitled Video";
      const descriptionContainer = document.getElementById("videoDescription");
descriptionContainer.innerHTML = ""; // clear old content

(result.description || "")
  .split("\n")
  .forEach(line => {
    const p = document.createElement("p");
    p.textContent = line;
    descriptionContainer.appendChild(p);
  });

      async function makeLink(url, fallbackText, fetchTitle = false) {
  if (!url) return document.createTextNode(fallbackText);

  let text = url;

  // Optional: fetch page title
  if (fetchTitle && /^https?:\/\//i.test(url)) {
    try {
      const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
      const data = await response.json();
      const match = data.contents.match(/<title>(.*?)<\/title>/i);
      if (match && match[1]) {
        text = match[1].trim();
      }
    } catch (e) {
      console.warn("Could not fetch title for:", url, e);
    }
  }

  const a = document.createElement("a");
  a.href = url;
  a.target = "_blank";
  a.rel = "noopener noreferrer";
  a.textContent = text;

  return a;
}

(async () => {
  const authorElement = document.getElementById("videoAuthor");
  authorElement.textContent = "From ";

  // Detect if author is a URL or just text
  if (/^(https?:|data:)/i.test(result.author)) {
    const link = await makeLink(result.author, result.author, true /* fetchTitle optional */);
    authorElement.appendChild(link);
  } else {
    authorElement.appendChild(document.createTextNode(result.author));
  }

  authorElement.appendChild(document.createTextNode(` at ${formatDeadline(result.uploadDate, false) || result.uploadDate}`));

  document.getElementById("videoDeadline").textContent =
    `Deadline: ${formatDeadline(result.deadlineRaw, true) || result.deadlineRaw}`;

  // Spreadsheet Link
  const spreadsheetLink = document.getElementById("spreadsheetLink");
  if (result.spreadsheetHref) {
    const link = await makeLink(result.spreadsheetHref, "Spreadsheet");
    spreadsheetLink.replaceWith(link);
    link.id = "spreadsheetLink"; // Keep same ID if needed
  } else {
    spreadsheetLink.href = "#";
  }

  // External Link
  const externalLink = document.getElementById("externalLink");
  if (result.externalHref) {
    const link = await makeLink(result.externalHref, "External");
    externalLink.replaceWith(link);
    link.id = "externalLink"; // Keep same ID if needed
  } else {
    externalLink.href = "#";
  }

  document.getElementById("commentCount").textContent =
    `${result.comments || 0} Comments`;
})();

      if (result.videoLink) {
        document.getElementById("videoPreview").src = result.videoLink;
        document.getElementById("videoPreview").style.width = `${result.width}px`;
        document.getElementById("videoPreview").style.height = `${result.height}px`;
      }

    } catch (err) {
      console.error(err);
      document.getElementById("videoTitle").textContent = "Error loading video.";
    }
  }

  loadVideoData();
updateCountdown("2025-08-15T12:00:00.000Z", true);
setInterval(() => updateCountdown("2025-08-15T12:00:00.000Z", true), 1000);
</script>


</body>
</html>



