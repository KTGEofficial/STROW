<html>
<head>
    <style id="dynamic-theme"></style>
  <script>
    const lightCSS = `
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(to bottom left, hsl(180, 96%, 96%), hsl(150, 96%, 96%));
        font-family: sans-serif;
      }

      .grid-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(to right, rgba(255, 255, 255, 0.5) 8px, transparent 1px),
          linear-gradient(to bottom, rgba(255, 255, 255, 0.5) 8px, transparent 1px);
        background-size: 40px 40px;
        pointer-events: none;
        z-index: 0;
      }

      .content {
        position: relative;
        z-index: 1;
        padding: 2rem;
        text-align: center;
      }
    `;

    const darkCSS = `
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: linear-gradient(to bottom left, hsl(240, 96%, 16%), hsl(0, 0%, 0%), hsl(332, 96%, 32%));
        font-family: sans-serif;
        color: white;
      }

      .grid-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-image: 
          linear-gradient(to right, rgba(255, 255, 255, 0.125) 8px, transparent 1px),
          linear-gradient(to bottom, rgba(255, 255, 255, 0.125) 8px, transparent 1px);
        background-size: 40px 40px;
        pointer-events: none;
        z-index: 0;
      }

      .content {
        position: relative;
        z-index: 1;
        padding: 2rem;
        text-align: center;
      }
    `;

    function applyTheme() {
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const styleTag = document.getElementById('dynamic-theme');
      styleTag.textContent = prefersDark ? darkCSS : lightCSS;
    }

    applyTheme();

    // Optional: Listen for changes in system theme
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', applyTheme);
  </script><title>Watching STROW</title><style>
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrolling on <html> */
            background: linear-gradient(to bottom left, hsl(180, 96%, 96%), hsl(150, 96%, 96%));
            font-family: sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-y: auto; /* ? Enable vertical scroll on body only */
            overflow-x: hidden; /* Prevent horizontal scroll */
            position: relative;
            z-index: 1; /* Ensure body content is above the grid */
        }

        .grid-overlay {
            position: fixed; /* Stays in place while scrolling */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(to right, rgba(255, 255, 255, 0.5) 8px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.5) 8px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none; /* ? Allows interaction with content and scrollbar */
            z-index: 0; /* Behind all content */
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            transition: all 0.3s ease;
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            /* Green glow when not focused */
            box-shadow: 0 0 8px rgba(0, 255, 127, 0.4);
            transition: box-shadow 0.3s ease;
        }

            /* Optional: subtle cyan glow on focus */
            input[type="text"]:focus,
            input[type="url"]:focus {
                box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
            }
.button-link,
.button-link:focus,
.button-link:active {
  outline: none;
  border: none;
}

        .button-link {
            position: relative;
            display: inline-block;
            text-decoration: none;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 1rem;
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F); /* Gradient restored */
            box-shadow: 0 4px 8px rgba(0, 255, 127, 0.3);
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 1;
        }


            .button-link:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 12px rgba(0, 255, 255, 0.4);
            }

            .button-link:active {
                transform: scale(0.98);
                box-shadow: 0 2px 6px rgba(0, 255, 255, 0.2);
            }

        .ripple-outline {
            position: absolute;
            border: 2px solid rgba(0, 255, 255, 0.4); /* Soft green glow */
            border-radius: 1rem;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            transform: scale(1);
            animation: ripple-outline-animation 800ms ease-out;
            pointer-events: none;
            z-index: 0; /* Behind the button text 2:06:58:53 */

        }


        @keyframes ripple-outline-animation {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="grid-overlay"></div>

<div style="position: relative; height: 100vh; background-color: hsl(0deg 0% 100% / 0%); padding: 2rem;"><form>
  <iframe
    id="videoPreview"
    src=""
    frameborder="0"
    allowfullscreen
    style="width: 840px; height: 472.5px;">
  </iframe>

  <h1 id="videoTitle">Loading Title</h1>

  <h2 id="countdown">Waiting for deadline</h2>

  <p id="videoDescription">Loading description</p>

  <h4 id="videoAuthor">From undefined at undefined</h4>

  <p id="videoDeadline">Deadline: Loading</p>

  <a id="spreadsheetLink" class="button-link">Spreadsheet</a>
  <a id="externalLink" class="button-link">Alternate External</a>

  <h2 id="commentCount">0 Comments</h2>
</form></div>
<script>
// Function to get raw fingerprint data from various browser traits
async function getRawFingerprintData() {
  const traits = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    screen.colorDepth,
    new Date().getTimezoneOffset(),
    navigator.platform,
    navigator.hardwareConcurrency,
    navigator.deviceMemory || 'unknown',
  ];
  return traits.join('::');
}

// Function to generate a SHA-256 hash from the raw fingerprint data
async function generateHexFingerprint(rawData) {
  const encoder = new TextEncoder();
  const buffer = await crypto.subtle.digest('SHA-256', encoder.encode(rawData));
  return Array.from(new Uint8Array(buffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

// Function to update the countdown display (PATCHED)
function updateCountdown(deadlineRaw, hasDeadline) {
  const countdownElement = document.getElementById("countdown");

  if (!hasDeadline || !deadlineRaw) {
    countdownElement.textContent = "No deadline";
    return;
  }

  // Convert deadlineRaw to a timestamp if it's a string
  let deadlineTime = typeof deadlineRaw === "number" ? deadlineRaw : Date.parse(deadlineRaw);
  if (isNaN(deadlineTime)) {
    countdownElement.textContent = "Invalid deadline date";
    return;
  }

  const now = Date.now();
  const distance = deadlineTime - now;

  if (distance <= 0) {
    countdownElement.textContent = "The deadline has passed";
    return;
  }

  const days = Math.floor(distance / (1000 * 60 * 60 * 24));
  const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
  const minutes = Math.floor((distance / (1000 * 60)) % 60);
  const seconds = Math.floor((distance / 1000) % 60);

  let partsToDisplay = [];

  if (days >= 1) {
    partsToDisplay.push(`${days}:${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (hours >= 1) {
    partsToDisplay.push(`${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (minutes >= 1) {
    partsToDisplay.push(`${minutes}:${String(seconds).padStart(2, '0')}`);
  } else {
    partsToDisplay.push(`${seconds} seconds`);
  }

  countdownElement.textContent = partsToDisplay.join("");
}

// Function to format the date and time for display
function formatDeadline(dateString, includeTime = false, timezoneAbbreviation) {
  const date = new Date(dateString);

  if (isNaN(date.getTime())) {
    return "Invalid Date";
  }

  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  let formatted = date.toLocaleDateString(undefined, options);

  // Add ordinal suffix (1st, 2nd, 3rd, 4th...)
  const day = date.getDate();
  const suffix = (day % 10 === 1 && day !== 11) ? 'st' :
                 (day % 10 === 2 && day !== 12) ? 'nd' :
                 (day % 10 === 3 && day !== 13) ? 'rd' : 'th';
  formatted = formatted.replace(/\d+/, day + suffix);

  if (includeTime) {
    const timeOptions = {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    };
    // NO timeZone property; uses the browser's local zone
    const localTime = `${date.toLocaleTimeString(undefined, timeOptions)} ${timezoneAbbreviation}`;
    formatted += ` at ${localTime}`;
  }

  return formatted;
}

// Main function to load video data and update the page
async function loadVideoData() {
  const params = new URLSearchParams(window.location.search);
  const id = params.get("id");

  if (!id) {
    window.location.href = "https://ktgeofficial.github.io/STROW/";
    return;
  }

  const rawData = await getRawFingerprintData();
  const fingerprint = await generateHexFingerprint(rawData);

  const query = new URLSearchParams({
    mode: "watch",
    id,
    fingerprint,
    timezoneOffset: new Date().getTimezoneOffset(),
    timezoneAbbreviation: Intl.DateTimeFormat('en-US', {timeZoneName: 'short'}).formatToParts(new Date()).find(part => part.type === 'timeZoneName')?.value
  }).toString();

  try {
    const response = await fetch(`https://script.google.com/macros/s/AKfycbzS1NYBdDzwoJ_geOv3TNJBsxoJ8gPzhRM7Xc7MfH5HPv4XiGstEJDrWPaJSMrS0nPh/exec?${query}`);
    const result = await response.json();

    if (!result.success) {
      console.log(result);
      window.location.href = result.redirect || "https://ktgeofficial.github.io/STROW/";
      return;
    }

    async function makeLink(url, fetchTitle = false) {
      let text = url;

      if (fetchTitle && /^https?:\/\//i.test(url)) {
        try {
          const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
          const data = await response.json();
          const match = data.contents.match(/<title>(.*?)<\/title>/i);
          if (match && match[1]) text = match[1].trim();
        } catch (e) {
          console.warn("Could not fetch title for:", url, e);
        }
      }

      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = text;
      return a;
    }

    // Convert deadlineRaw to timestamp once for countdown logic
    const deadlineTimestamp = typeof result.deadlineRaw === "number"
      ? result.deadlineRaw
      : Date.parse(result.deadlineRaw);

    document.getElementById("videoTitle").textContent = result?.title?.trim();

    const descriptionContainer = document.getElementById("videoDescription");
    descriptionContainer.innerHTML = "";

    const descriptionLines = (result?.description || "").split("\n");
    descriptionLines.forEach(line => {
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const p = document.createElement("p");
        p.textContent = trimmedLine;
        descriptionContainer.appendChild(p);
      }
    });

    document.getElementById("videoAuthor").textContent =
      `From ${result.author} at ${formatDeadline(result.uploadDate, false, result.timezoneAbbreviation) || result.uploadDate}`;
    document.getElementById("videoDeadline").textContent =
      `Deadline: ${formatDeadline(result.deadlineRaw, true, result.timezoneAbbreviation) || result.deadlineRaw}`;
    document.getElementById("spreadsheetLink").href = result.spreadsheetHref || "#";
    document.getElementById("externalLink").href = result.externalHref || "#";
    document.getElementById("commentCount").textContent = `${result.comments || 0} Comments`;

    // PATCHED DYNAMIC COUNTDOWN LOGIC
    updateCountdown(deadlineTimestamp, !!deadlineTimestamp);
    setInterval(() => updateCountdown(deadlineTimestamp, !!deadlineTimestamp), 1000);

    if (result.videoLink) {
      document.getElementById("videoPreview").src = result.videoLink;
      document.getElementById("videoPreview").style.width = `${result.width}px`;
      document.getElementById("videoPreview").style.height = `${result.height}px`;
    }

  } catch (err) {
    console.error(err);
    document.getElementById("videoTitle").textContent = "Error loading video.";
  }
}
// This is a quality marker for if the HTML Page loaded is the correct one for debuggers
loadVideoData();
</script>


</body>
</html>








