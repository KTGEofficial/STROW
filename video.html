<html>
<head>
    <title>Watching STROW</title><style>
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevent scrolling on <html> */
            background: linear-gradient(to bottom left, hsl(180, 96%, 96%), hsl(150, 96%, 96%));
            font-family: sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow-y: auto; /* ? Enable vertical scroll on body only */
            overflow-x: hidden; /* Prevent horizontal scroll */
            position: relative;
            z-index: 1; /* Ensure body content is above the grid */
        }

        .grid-overlay {
            position: fixed; /* Stays in place while scrolling */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(to right, rgba(255, 255, 255, 0.5) 8px, transparent 1px), linear-gradient(to bottom, rgba(255, 255, 255, 0.5) 8px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none; /* ? Allows interaction with content and scrollbar */
            z-index: 0; /* Behind all content */
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            transition: all 0.3s ease;
        }

        input[type="text"],
        input[type="url"] {
            background-color: white;
            border: 3px solid transparent;
            border-radius: 1rem;
            padding: 0.6rem 1rem;
            font-size: 1rem;
            border-radius: 1rem;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            outline: none;
            /* Gradient border using background-clip */
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F), white;
            background-origin: border-box;
            background-clip: padding-box, border-box;
            /* Green glow when not focused */
            box-shadow: 0 0 8px rgba(0, 255, 127, 0.4);
            transition: box-shadow 0.3s ease;
        }

            /* Optional: subtle cyan glow on focus */
            input[type="text"]:focus,
            input[type="url"]:focus {
                box-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
            }
.button-link,
.button-link:focus,
.button-link:active {
  outline: none;
  border: none;
}

        .button-link {
            position: relative;
            display: inline-block;
            text-decoration: none;
            color: white;
            font-size: 1rem;
            font-weight: bold;
            padding: 0.75rem 1.5rem;
            border-radius: 1rem;
            background-image: linear-gradient(to bottom left, #00FFFF, #00FF7F); /* Gradient restored */
            box-shadow: 0 4px 8px rgba(0, 255, 127, 0.3);
            cursor: pointer;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            z-index: 1;
        }


            .button-link:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 12px rgba(0, 255, 255, 0.4);
            }

            .button-link:active {
                transform: scale(0.98);
                box-shadow: 0 2px 6px rgba(0, 255, 255, 0.2);
            }

        .ripple-outline {
            position: absolute;
            border: 2px solid rgba(0, 255, 255, 0.4); /* Soft green glow */
            border-radius: 1rem;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            transform: scale(1);
            animation: ripple-outline-animation 800ms ease-out;
            pointer-events: none;
            z-index: 0; /* Behind the button text 2:06:58:53 */

        }


        @keyframes ripple-outline-animation {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }

            100% {
                transform: scale(2.5);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="grid-overlay"></div>

<div style="position: relative; height: 100vh; background-color: hsl(0deg 0% 100% / 0%); padding: 2rem;"><form>
  <iframe
    id="videoPreview"
    src=""
    frameborder="0"
    allowfullscreen
    style="width: 840px; height: 472.5px;">
  </iframe>

  <h1 id="videoTitle">Loading Title</h1>

  <h2 id="countdown">Waiting for deadline</h2>

  <p id="videoDescription">Loading description</p>

  <h4 id="videoAuthor">From undefined at undefined</h4>

  <p id="videoDeadline">Deadline: Loading</p>

  <a id="spreadsheetLink" class="button-link">Spreadsheet</a>
  <a id="externalLink" class="button-link">Alternate External</a>

  <h2 id="commentCount">0 Comments</h2>
</form></div>
<script>// Function to get raw fingerprint data from various browser traits
async function getRawFingerprintData() {
  const traits = [
    navigator.userAgent,
    navigator.language,
    screen.width,
    screen.height,
    screen.colorDepth,
    new Date().getTimezoneOffset(),
    navigator.platform,
    navigator.hardwareConcurrency,
    navigator.deviceMemory || 'unknown',
  ];
  return traits.join('::');
}

// Function to generate a SHA-256 hash from the raw fingerprint data
async function generateHexFingerprint(rawData) {
  const encoder = new TextEncoder();
  const buffer = await crypto.subtle.digest('SHA-256', encoder.encode(rawData));
  return Array.from(new Uint8Array(buffer))
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}

/**
 * Creates a valid Date object from a potentially malformed date string.
 * It assumes the string is in UTC and handles common formats.
 * @param {string} dateString - The raw date string.
 * @returns {Date} A new Date object.
 */
function createUTCDate(dateString) {
  if (!dateString) return new Date(NaN);

  // If string already contains a "T" and possibly ends with "Z", it's ISO and can be parsed directly.
  if (/T.*Z$/.test(dateString)) {
    return new Date(dateString);
  }

  // If string is in "YYYY-MM-DD HH:mm:ss" format, convert to ISO.
  if (/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/.test(dateString)) {
    return new Date(dateString.replace(" ", "T") + "Z");
  }

  // Otherwise, let Date try its best.
  return new Date(dateString);
}

// Function to update the countdown display
function updateCountdown(deadlineRaw, hasDeadline) {
  const countdownElement = document.getElementById("countdown");

  if (!hasDeadline) {
    countdownElement.textContent = "No deadline";
    return;
  }

  const deadline = createUTCDate(deadlineRaw).getTime();
  
  // Check if the date is invalid (NaN)
  if (isNaN(deadline)) {
    countdownElement.textContent = "Invalid deadline format";
    return;
  }
  
  const now = Date.now();
  const distance = deadline - now;

  if (distance <= 0) {
    countdownElement.textContent = "The deadline has passed";
    return;
  }

  const days = Math.floor(distance / (1000 * 60 * 60 * 24));
  const hours = Math.floor((distance / (1000 * 60 * 60)) % 24);
  const minutes = Math.floor((distance / (1000 * 60)) % 60);
  const seconds = Math.floor((distance / 1000) % 60);

  let partsToDisplay = [];

  if (days >= 1) {
    partsToDisplay.push(`${days}:${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (hours >= 1) {
    const hoursStr = hours >= 10 ? hours : hours.toString();
    partsToDisplay.push(`${hoursStr}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`);
  } else if (minutes >= 1) {
    const minutesStr = minutes >= 10 ? minutes : minutes.toString();
    partsToDisplay.push(`${minutesStr}:${String(seconds).padStart(2, '0')}`);
  } else {
    partsToDisplay.push(`${seconds} seconds`);
  }

  countdownElement.textContent = partsToDisplay.join("");
}

// Function to format the date and time for display
function formatDeadline(dateString, includeTime = false) {
  const date = createUTCDate(dateString);

  if (isNaN(date.getTime())) {
    return "Invalid Date";
  }

  const options = { year: 'numeric', month: 'long', day: 'numeric' };
  let formatted = date.toLocaleDateString(undefined, options);

  // Add ordinal suffix (1st, 2nd, 3rd, 4th...)
  const day = date.getDate();
  const suffix = (day % 10 === 1 && day !== 11) ? 'st' :
                 (day % 10 === 2 && day !== 12) ? 'nd' :
                 (day % 10 === 3 && day !== 13) ? 'rd' : 'th';
  formatted = formatted.replace(/\d+/, day + suffix);

  if (includeTime) {
    const timeOptions = {
      hour: 'numeric',
      minute: '2-digit',
      hour12: true,
      timeZone: 'America/New_York', // ENSURE it's Delaware/Eastern Time!
      timeZoneName: 'short'
    };
    const localTime = date.toLocaleTimeString(undefined, timeOptions);
    formatted += ` at ${localTime}`;
  }

  return formatted;
}

// Main function to load video data and update the page
async function loadVideoData() {
  const params = new URLSearchParams(window.location.search);
  const id = params.get("id");

  if (!id) {
    window.location.href = "https://ktgeofficial.github.io/STROW/";
    return;
  }

  const rawData = await getRawFingerprintData();
  const fingerprint = await generateHexFingerprint(rawData);

  const query = new URLSearchParams({
    mode: "watch",
    id,
    fingerprint
  }).toString();

  try {
    const response = await fetch(`https://script.google.com/macros/s/AKfycbwVq1_Ex6uNvYnY16xiOYjaLObj4rmNWaeJQV38x4gtMEnCWmIMXFRo03cANtnSlho4/exec?${query}`);
    const result = await response.json();

    if (!result.success) {
      console.log(result);
      // Optional: redirect on fail
      window.location.href = result.redirect || "https://ktgeofficial.github.io/STROW/";
      return;
    }

    // Helper to create clickable <a> tags with optional page title fetching
    async function makeLink(url, fetchTitle = false) {
      let text = url;

      // Only fetch title for HTTP/HTTPS
      if (fetchTitle && /^https?:\/\//i.test(url)) {
        try {
          const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(url)}`);
          const data = await response.json();
          const match = data.contents.match(/<title>(.*?)<\/title>/i);
          if (match && match[1]) text = match[1].trim();
        } catch (e) {
          console.warn("Could not fetch title for:", url, e);
        }
      }

      const a = document.createElement("a");
      a.href = url;
      a.target = "_blank";
      a.rel = "noopener noreferrer";
      a.textContent = text;
      return a;
    }

    // Function to convert text into <p> elements and linkify URLs
    // Set video title with fallback
    const titleElement = document.getElementById("videoTitle");
    titleElement.textContent = result?.title?.trim();

    // Clear and populate video description
    const descriptionContainer = document.getElementById("videoDescription");
    descriptionContainer.innerHTML = "";

    const descriptionLines = (result?.description || "").split("\n");

    descriptionLines.forEach(line => {
      const trimmedLine = line.trim();
      if (trimmedLine) {
        const p = document.createElement("p");
        p.textContent = trimmedLine;
        descriptionContainer.appendChild(p);
      }
    });

    document.getElementById("videoAuthor").textContent = `From ${result.author} at ${formatDeadline(result.uploadDate, false) || result.uploadDate}`;
    document.getElementById("videoDeadline").textContent = `Deadline: ${formatDeadline(result.deadlineRaw, true) || result.deadlineRaw}`;
    document.getElementById("spreadsheetLink").href = result.spreadsheetHref || "#";
    document.getElementById("externalLink").href = result.externalHref || "#";
    document.getElementById("commentCount").textContent = `${result.comments || 0} Comments`;
    
    // START OF DYNAMIC COUNTDOWN LOGIC
    // Initial call to start the countdown
    updateCountdown(result.deadlineRaw, !!result.deadlineRaw);
    
    // Set up the interval to update the countdown every second
    setInterval(() => updateCountdown(result.deadlineRaw, !!result.deadlineRaw), 1000);
    // END OF DYNAMIC COUNTDOWN LOGIC

    if (result.videoLink) {
      document.getElementById("videoPreview").src = result.videoLink;
      document.getElementById("videoPreview").style.width = `${result.width}px`;
      document.getElementById("videoPreview").style.height = `${result.height}px`;
    }

  } catch (err) {
    console.error(err);
    document.getElementById("videoTitle").textContent = "Error loading video.";
  }
}

loadVideoData();
</script>


</body>
</html>
